# 装饰者模式
装饰者模式可以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。

应用场景：

* `counterxing`写了一堆辣鸡代码，然后他跑路回学校毕业去了。`giminzeng`接手了他的辣鸡代码，发现他写的函数根本就看不懂，甚至可能还用了`a`、`b`、`c`这种变量命名方式，还可能没有注释。`giminzeng`想给这些代码增添新功能，又不想直接去覆盖之前的代码，于是使用装饰者模式，动态地给某个对象添加一些额外的职责。
* 我们想给`window`绑定`onload`事件，但是又不确定这个事件是不是已经被其他人绑定过，为了避免覆盖掉之前的`window.onload`函数中的行为，我们一般都会先保存好原先的`window.onload`，把它放入新的`window.onload`里执行。

**为何不使用继承？**

* 导致超类和子类之间存在强耦合性，当超类改变时，子类也会随之改变;
* 超类的内部细节是对子类可见的，继承常常被认为破坏了封装性;
* 可能会创建出大量的子类，使子类的数量呈爆炸性增长。

例如：现在有`4`种型号的自行车，我们为每种自行车都定义了一个单独的类。要给每种自行车都装上前灯、尾 灯和铃铛这3种配件。如果使用继承的方式来给每种自行车创建子类，则需要`4 × 3 = 12`个子类。 但是如果把前灯、尾灯、铃铛这些对象动态组合到自行车上面，则只需要额外增加`3`个类。

给对象动态地增加职责的方式称为装饰者(`decorator`)模式。装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。

![](http://image.jiantuku.com/17-7-30/57675551.jpg?attname=file_1501428671868_12de.png&e=1501429210&token=el7kgPgYzpJoB23jrChWJ2gV3HpRl0VCzFn8rKKv:efBGQzyb13jz3xdZ1lJfFDA7xlw=)

## 15.1模拟传统面向对象语言的装饰者模式
作为一门解释执行的语言，给`JavaScript`中的对象动态添加或者改变职责是一件再简单不过的事情，虽然这种做法改动了对象自身，跟传统定义中的装饰者模式并不一样，但这无疑更符合`JavaScript`的语言特色。

```javascript
var obj = {
  name: 'sven',
  address: '深圳市'
};
obj.address = obj.address + '福田区';
```

传统面向对象语言中的装饰者模式在`JavaScript`中适用的场景并不多，如上面代码所示，通常我们并不太介意改动对象自身模拟一下传统面向对象语言中的`装饰者模式`实现。

假设我们在编写一个飞机大战的游戏，随着经验值的增加，我们操作的飞机对象可以升级成更厉害的飞机，一开始这些飞机只能发射普通的子弹，升到第二级时可以发射导弹，升到第三级时可以发射原子弹。

```javascript
// 定义飞机类
var Plane = function() {};
Plane.prototype.fire = function() {
  console.log('发射普通子弹');
};

// 增加两个装饰类，分别是导弹和原子弹

// 装饰导弹
var MissileDecorator = function(plane) {
  this.plane = plane;
}
MissileDecorator.prototype.fire = function() {
  this.plane.fire(); // 调用其本身的fire方法
  console.log('发射导弹');
}
// 装饰原子弹
var AtomDecorator = function(plane) {
  this.plane = plane;
}
AtomDecorator.prototype.fire = function() {
  this.plane.fire(); // 调用其本身的fire方法
  console.log('发射原子弹');
}
var plane = new Plane();
plane = new MissileDecorator(plane); // 装饰上导弹装饰类
plane = new AtomDecorator(plane); // 装饰上原子弹装饰类
plane.fire(); // 分别输出: 发射普通子弹、发射导弹、发射原子弹
```

导弹类和原子弹类的构造函数都接受参数`plane`对象，并且保存好这个参数，在它们的`fire`方法中，除了执行自身的操作之外，还调用`plane`对象的`fire`方法。

这种给对象动态增加职责的方式，并没有真正地改动对象自身，而是将对象放入另一个对象之中，这些对象以一条链的方式进行引用，形成一个聚合对象。这些对象都拥有相同的接口(`fire`方法)，当请求达到链中的某个对象时，这个对象会执行自身的操作，随后把请求转发给链中的下一个对象。

因为装饰者对象和它所装饰的对象拥有一致的接口，所以它们对使用该对象的客户来说是**透明**的，被装饰的对象也并不需要了解它曾经被装饰过，这种透明性使得我们可以递归地嵌套任意多个装饰者对象。

> 我的理解：好比我在玩英雄联盟/王者荣耀，我通过给我的英雄加点、带天赋、符文等，并没有改变我这个英雄本身，对外也是透明的(我还是使用的这个英雄)，还可以穿多个装备加多次点。但是在对战过程中，装备好的把装备差的击杀了，恰好正证明了我通过装饰增加了功能。

![](http://image.jiantuku.com/17-7-30/55221201.jpg?attname=file_1501429518422_17bc8.png&e=1501430410&token=el7kgPgYzpJoB23jrChWJ2gV3HpRl0VCzFn8rKKv:mJjSvc4-o554E8A7buobnDAoHKY=)

## 15.3回到JavaScript的装饰者
`JavaScript`语言动态改变对象相当容易，我们可以直接改写对象或者对象的某个方法，并不需要使用`类`来实现装饰者模式。

```javascript
// 定义飞机
var plane = {
  fire: function() {
    console.log('发射普通子弹');
  }
}
// 定义发射导弹函数
var missileDecorator = function() {
  console.log('发射导弹');
}
// 定义发射原子弹函数
var atomDecorator = function() {
  console.log('发射原子弹');
}
// 拿到发射子弹函数
var fire1 = plane.fire;
// 重写函数，除了调用原函数，还调用装饰函数
plane.fire = function() {
  fire1();
  missileDecorator();
}
var fire2 = plane.fire;
plane.fire = function() {
  fire2();
  atomDecorator();
}
plane.fire(); // 分别输出: 发射普通子弹、发射导弹、发射原子弹
```

## 15.4装饰函数
要想为函数添加一些功能，最简单粗暴的方式就是直接改写该函数。

```javascript
var a = function() {
  console.log(1);
}
var a = function() {
  console.log(1);
  console.log(2);
}
```

显然不可行！违背**开放-封闭原则(封装变化、降低耦合)**

通过保存原引用的方式就可以改写某个函数。(上边的做法就是这么做的)

```javascript
var a = function() {
  console.log(1);
}
var _a = a;

a = function() {
  _a();
  console.log(2);
}
a(); // 依次输出1、2
```

回到最开始说的那种应用场景：

```javascript
window.onload = function() {
  console.log(1);
}
var _onload = window.onload || function() {};
window.onload = function() {
  _onload();
  console.log(2);
}
```

存在一些问题：

* 必须维护`_onload`这个中间变量，虽然看起来并不起眼，但如果函数的装饰链较长，或者需要装饰的函数变多，这些中间变量的数量也会越来越多。
* 遇到了`this`被劫持的问题，在`window.onload`的例子中没有这个烦恼，是因为调用普通函数`_onload`时，`this`也指向`window`，跟调用`window.onload`时一样(函数作为对象的方法被调用时，`this`指向该对象，所以此处`this`也只指向`window`)。现在把`window.onload`换成`document.getElementById`，代码如下:

```javascript
var _getElementById = document.getElementById;
document.getElementById = function(id) {
  console.log(1);
  return _getElementById(id);
}
var button = document.getElementById('button'); // 报错，详情见第二章讲义：丢失的this
```

解决办法，使用`apply`。

```javascript
var _getElementById = document.getElementById;
document.getElementById = function() {
  console.log(1);
  return _getElementById.apply(document, arguments);
}
var button = document.getElementById('button');
```

## 15.5 用AOP装饰函数（具体可见之前第三章讲义的AOP相关内容）

